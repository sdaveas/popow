\subsection{Security}

The prior PoPoW protocol~\cite{KLS} designed to prevent Bahack-style
attacks~\cite{bahack}, where the adversary constructs ``lucky'' high-difficulty
superblocks without filling in the underlying proof-of-work in the lower
levels.
Our protocol retains this highlevel approach, but adds a defense against the double-spending attack of Section~\ref{sec:attack}.
The attack is neutralized since our
verifier is more permissive, allowing the prover to construct a proof that takes superquality  ``goodness'' into account when comparing forks.

%Our verifier checks a looser condition than the PoPoW verifier.
%Under ordinary conditions, the proofs constructed by the 

\begin{restatable}{theorem}{restateThmSecurity}
    \label{thm.security}
    Assuming honest majority, the non-interactive proofs-of-proof-of-work
    construction for $k$-stable monotonic suffix-sensitive predicates is secure
    with overwhelming probability in $\kappa$.
\end{restatable}

We will first give a sketch of the proof before getting into 
details. Suppose an adversary produces a proof $\pi_\mathcal{A}$ and an honest
party produces a proof $\pi_B$ such that the two proofs cause the predicate $Q$
to evaluate to different values, while at the same time all honest parties have
agreed that the correct value is the one obtained by $\pi_B$. Because of
bitcoin's security, $\mathcal{A}$ will be unable to make these claims for an
actual underlying 0-level chain.

We now argue that the operator $\leq_m$ will
signal in favour of the honest parties.
Suppose $b$ is the LCA block between $\pi_\mathcal{A}$ and $\pi_B$. If the chain
forks at $b$, there can be no more adversarial blocks after $b$ than honest
blocks after $b$, provided there are at least $k$ honest blocks (due to the
Common Prefix property). We will now argue that, further, there can be no more
disjoint $\mu_\mathcal{A}$-level superblocks than honest $\mu_B$-level
superblocks after $b$.

To see this, let $b$ be an honest block generated at some round $r_1$ and let
the honest proof have been generated at some round $r_3$. Then take the sequence
of consecutive rounds $S = (r_1, \cdots, r_3)$. Because the verifier requires at
least $m$ blocks from each of the provers, the adversary must have $m$
$\mu_\mathcal{A}$-superblocks in $\pi_\mathcal{A}\{b:\}$ which are not in
$\pi_B\{b:\}$. Therefore, using a negative binomial tail bound argument, we see
that $|S|$ must be long; intuitively, it takes a long time to produce a lot of
blocks $|\pi_\mathcal{A}\{b:\}|$. Given that $|S|$ is long and that the honest
parties have more mining power, they must have been able to produce a longer
$\pi_B\{b:\}$ argument (of course, this comparison will have the superchain
lengths weighted by $2^{\mu_\mathcal{A}}, 2^{\mu_B}$ respectively). To prove
this, we use a binomial tail bound argument; intuitively, given a long time
$|S|$, a lot of $\mu_B$-superblocks $|\pi_B\{b:\}|$ will have been honestly
produced.

We therefore have a fixed value for the length of the adversarial argument, a
negative binomial random variable for the number of rounds, and a binomial
random variable for the length of the honest argument. By taking the
expectations of the above random variables and applying a Chernoff bound, we see
that the actual values will be close to their means with overwhelming
probability, completing the proof.

%
%Observe that, while setting $m = 1$ ``preserves'' the proof-of-work in
%the sense that expectations remain the same, the probability of an adversarial
%attack becomes approximately proportional to the adversary power if the
%adversary follows a suitable strategy (for a description of such a strategy,
%see the parameterization section). With higher values of $m$, the probability of
%an adversarial attack drops exponentially in $m$, even though they maintain constant
%computational power, and hence satisfy a strong notion of security.
%
%

%blockchains into account when choosing levels, 
%and the verifier may compare proofs at the right level.

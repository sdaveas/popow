\section{Model and Definitions}
\label{sec.model}
Our model for describing our results is based on the standard ``backbone'' model for proof-of-work cryptocurrencies~\cite{backbone}, extended with the widely used Simplified Payment Verification (SPV) mode due to Nakamoto~\cite{bitcoin}.
We consider three roles in our setting: lightweight \emph{clients},  full \emph{nodes}, and \emph{miners}.\footnote{Full nodes can be thought of as miners with zero hashpower, we use this terminology to be consistent with Bitcoin developers.}

Nodes and miners run the Bitcoin backbone protocol, maintaining a copy of the blockchain and committing new transactions they receive from clients.
Clients do not store the entire blockchain, but instead connect to nodes for service and request up-to-date information about the blockchain, for example whether a particular payment has been finalized. Our main challenge is to design a protocol so that clients can sieve through  the responses they receive from
the network and reach a conclusion that should never disagree with the conclusion of a full  node
who is faced
with the same objective and infers it from its local blockchain  state.

\subsection{Backbone model}

% AM:
%We define our problem in the setting of a blockchain client which is completely
%stateless beyond the knowledge of a common reference string, the genesis block.
%Without loss of generality, this single reference block could be any stable
%checkpoint block, either hard-coded in the client or obtained through a previous
%interaction with the network.

The entities on the blockchain network are of 3 kinds: (1) miners, who
try to mine new blocks on top of the longest known blockchain and broadcast them
as soon as they are discovered (for simplicity we assume that difficulty
is constant and thus the ``longest chain rule'' sufficiently describes honest miner behavior); (2) full nodes, who maintain the longest
blockchain without mining and also act as the provers in the network; (3)
verifiers or stateless clients, who connect to provers and ask for proofs in
regards to which blockchain is the largest. The verifiers attempt to determine
the value of a predicate on these chains.

We model proof-of-work discovery attempts by using a random oracle~\cite{RO} as
in \cite{backbone}.%
\footnote{For clarity, we present our results in the backbone model~\cite{backbone}, although we suspect our results transfer easily to more refined models, such as Pass et al.~\cite{PSS}.}%

The random oracle produces $\kappa$-bit strings, where
$\kappa$ is the system's security parameter. The network is synchronized into
numbered rounds, which correspond to moments in time. $n$ denotes the total
number of miners in the game, while $t$ denotes the total number of adversarial
miners. Each miner is assumed to have equal mining power captured by the number
of queries $q$ available per player to the random oracle, each query of which
succeeds independently with probability $p$ (a successful query produces a block
with valid proof-of-work). Mining pools and miners of different computing power
can be captured by assuming multiple players combine their computing power. This
is made explicit for the adversary, as they do not incur any network overhead to
achieve communication between adversarial miners. On the contrary, honest
players discovering a block must \textit{diffuse} it (broadcast it) to the
network at a given round and wait for it to be received by the rest of the
honest players at the beginning of the next round. A round during which an
honest block is diffused is called a \textit{successful round}; if the number of
honest blocks diffused is one, it is called \textit{uniquely successful round}.
We assume there is an honest majority, i.e., that $t / n < 0.5$ with a
significant gap~\cite{backbone}. We further assume that the network is
adversarial, but that there is no eclipsing attacks~\cite{heilman2015eclipse}. More
specifically, we allow the adversary to reorder messages transmitted at a
particular round, to inject new messages thereby capturing Sybil attacks~
\cite{sybil}, but not to drop messages. Each honest miner maintains a local
chain $\chain$ which they consider the current active blockchain. Upon receiving
a different blockchain from the network, the current active blockchain is
changed if the received blockchain is longer than the currently adopted one.
Receiving a different blockchain of the same length as the currently adopted one
does not change the adopted blockchain.

Blockchain blocks are generated by including the following data in them: $ctr$,
the nonce used to achieve the proof-of-work; $x$ the Merkle tree~\cite{merkle} root of the
transactions confirmed in this block; and \textit{interlink}, a vector
containing pointers to previous blocks, including the id of the previous block.
The \textit{interlink} data structure contains pointers to more blocks than just
the previous block. We will explain this further in Section~
\ref{sec.consensus}. Given two hash functions $H$ and $G$ modelled as random
oracles, the id of a block is defined as $\textsf{id} = H(ctr, G(x,
\textsf{interlink}))$. In bitcoin's case, both $H$ and $G$ would be SHA256.

\subsection{The prover and verifier model}
In our protocol, the nodes include a \emph{proof} along with their responses to clients.
We need to assume that clients are able to connect to at least one correctly functioning node (i.e., that they cannot be eclipsed from the network~\cite{heilman2015eclipse,hijackingbitcoin}).
Each client makes the same request to every node, and by verifying the proofs the client identifies the correct response.
Henceforth we will call clients \textit{verifiers} and nodes \textit{provers}.
Note that in the interactive protocol from prior work~\cite{KLS},  the prover and verifier may engage in more than one round of message passing.

The prover-verifier interaction is parameterized by a predicate (e.g. ``the transaction $t$ is committed in the blockchain'').
%
The predicates of interest in our context are predicates on the active
blockchain. Some of the predicates are more suitable for succinct proofs than
others. We focus our attention in \textit{stable} predicates having the property
that all honest miners share their view of them in a way that is updated in a
predictable manner, with a truth-value that persists as the blockchain grows (an
example of an unstable predicate is e.g., the least significant bit of the hash
of last block). Following the work of \cite{backbone}, we wait for $k$ blocks to
bury a block before we consider it \textit{confirmed} and thereby the predicates
depending on it stable. $k$ is the \textit{common prefix} security parameter,
which in bitcoin folklore is often taken to be $k = 6$.

In our setting, for a given predicate $Q$, several  provers (including
adversarial ones) will generate proofs claiming potentially different truth
values for $Q$ based on their claimed local longest chains. The verifier
receives these proofs and accepts one of the proofs, determining the truth value
of the predicate.  We denote a  \textit{blockchain proof protocol} for a
predicate $Q$ as a pair $(P, V)$ where $P$ is the \textit{prover} and $V$ is the
\textit{verifier}. $P$ is a PPT algorithm that is spawned by a full node when
they wish to produce a proof, accepts as input a full chain $\chain$ and
produces a proof $\pi$ as its output. $V$ is a PPT algorithm which is spawned at
some round, receives a pair of proofs $(\pi_A, \pi_B)$ from both an honest party
and the adversary and returns its decision $d \in \{T, F, \bot\}$ before the
next round and terminates. The honest miners produce proofs for $V$ using $P$,
while the adversary produces proofs following some arbitrary strategy. Before we
introduce the security properties for blockchain proof protocols we introduce
some necessary notation for blockchains.

\subsection{Blockchain notation and conventions}
% \noindent {\bf Blockchain addressing.}
Our development makes use of several notation conventions for manipulating blockchain data structures, which we introduce here.
Blockchains are finite block sequences obeying the \textit{blockchain property}
that in every block in the chain there exists a pointer to its previous block.
A chain is \textit{anchored} if its first block is \textit{genesis}, denoted
$Gen$.

For chain addressing we use Python brackets $\chain[\cdot]$ as in
\cite{fruitchains}. A zero-based positive number in a bracket indicates the
indexed block in the chain. A negative index indicates a block from the end,
e.g., $\chain[-1]$ is the tip of the blockchain. A range $\chain[i:j]$ is a
subarray starting from $i$ (inclusive) to j (exclusive).

Given chains $\chain_1, \chain_2$ and blocks $A, Z$ we concatenate them as
$\chain_1 \chain_2$ or $\chain_1 A$. $\chain_2[0]$ must point to $\chain_1[-1]$
and $A$ must point to $\chain_1[-1]$. We denote $\chain\{A:Z\}$ the subarray of
the chain from $A$ (inclusive) to $Z$ (exclusive). We can omit blocks or indices
from either side of the range to take the chain to the beginning or end
respectively.

\textbf{Helper functions for blockchains.} The \textit{id} function returns the
id of a block given its data, i.e., $\textsf{id} = H(ctr, G(x,
\textsf{interlink}))$. % \cite{princetonbook}
 \textit{depth} is a function which, given a block, returns
its distance from the genesis block.

Valid blocks satisfy the proof-of-work condition: $id \leq T$, where $T$ is the
mining target. Throughout this work, we make the simplifying assumption that $T$
is constant. Some blocks will achieve a lower id. If $id \leq \frac{T}{2^\mu}$
we say that the block is of level $\mu$. All blocks are level $0$. Blocks with
level $\mu$ are called $\mu$-\textit{superblocks}.
$\mu$-superblocks for $\mu > 0$ are also $(\mu - 1)$-superblocks.
% The level of a block is given as
% $\mu = \left \lfloor \log(T) - \log(\sf{id}(B)) \right \rfloor$ and denoted
% $\textit{level}(B)$.
By convention, for $Gen$ we set $id = 0$ and $\mu = \infty$.

In this paper, we will extend blocks to contain multiple pointers to previous
blocks. Certain blocks can be omitted from a chain, obtaining a subchain, as
long as the blockchain property that each block must contain a pointer to its
previous block in the sequence is maintained.

Blockchains are sequences, but it is more convenient to use set notation for
some operations. Specifically, $B \in \chain$; $\chain_1 \subseteq \chain_2$ and
$\emptyset$ have the obvious meaning. $\chain_1 \cup \chain_2$ is the chain
obtained by sorting the blocks contained in both $\chain_1$ and $\chain_2$ into
a sequence (this may be not always defined).
We will freely use set builder notation $\{B \in \chain: p(B)\}$.
$\chain_1 \cap \chain_2$ is the
chain $\{B: B \in \chain_1 \land B \in \chain_2\}$. In all cases, the
blockchain property must be maintained. The lowest common ancestor is
$\textsf{LCA}(\chain_1,
\chain_2) = (\chain_1 \cap \chain_2)[-1]$.
If $\chain_1[0] = \chain_2[0]$ and $\chain_1[-1] = \chain_2[-1]$, we say the
chains $\chain_1, \chain_2$ \textit{span} the same block range.

It will soon become clear that it is useful to construct a chain containing only
the superblocks of another chain. Given $\chain$ and level $\mu$, the
\textit{upchain} $\chain\upchain^\mu$ is defined as $\{B \in \chain: level(B) \geq \mu\}$.
A chain containing only $\mu$-superblocks is called a $\mu$\textit{-superchain}. It is
also useful, given a $\mu$-superchain $\chain'$ to go back to the regular chain
$\chain$. Given chains $\chain' \subseteq \chain$, the \textit{downchain}
$\chain'\downchain\!\!_\chain$ is defined as $\chain[\chain'[0]:\chain'[-1]]$. $\chain$
is the \textit{underlying chain} of $\chain'$. The underlying chain is often
implied by context, so we will simply write $\chain'\downchain$. By the above
definition, the $\chain\upchain$ operator is absolute:
$(\chain\upchain^\mu)^{\mu + i} = \chain\upchain^{\mu + i}$. Given a set of
consecutive rounds $S = \{r, r + 1, \cdots, r + j\} \subseteq \mathbb{N}$, we define $\chain^S = \{B
\in \chain: B \text{ was generated during } S\}$.

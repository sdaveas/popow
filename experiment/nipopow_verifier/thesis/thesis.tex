\documentclass{article}
\usepackage[utf8]{inputenc}

\title{A gas-efficient superlight Bitcoin client in Solidity}
\begin{document}

\maketitle

\begin{abstract}
Place abstract here
\end{abstract}

\section{Introduction}
This is the intro
\subsection{Motivation}
Added value of the project
\subsection{Our contributions}
Added value of the project

\section{Background}
Relevant technologies
\subsection{Primitives}
Describe primitives
\subsection{Bitcoin}
Describe Bitcoin blockchain
\subsection{Ethereum}
Describe Ethereum blockchain
\subsubsection{Solidity}
Describe the use of solidity language
\subsubsection{Smark contracts}
Describe the use of smart contracts
\subsubsection{Ethereum Virtual Machine}
The Ethereum Virtual Machine (EVM) is a sandboxed virtual stack embedded within each full Ethereum node, responsible for executing contract bytecode. Contracts are typically written in higher level languages, like Solidity, then compiled to EVM bytecode.

This means that the machine code is completely isolated from the network, filesystem or any processes of the host computer. Every node in the Ethereum network runs an EVM instance which allows them to agree on executing the same instructions. The EVM is Turing complete, which refers to a system capable of performing any logical step of a computational function. JavaScript, the programming language which powers the worldwide web, widely uses Turing completeness.

Ethereum Virtual Machines have been successfully implemented in various programming languages including C++, Java, JavaScript, Python, Ruby, and many others.

The EVM is essential to the Ethereum Protocol and is instrumental to the consensus engine of the Ethereum system. It allows anyone to execute code in a trustless ecosystem in which the outcome of an execution can be guaranteed and is fully deterministic (i.e.) executing smart contracts.
\subsection{Non-Interactive Proofs Of Proof Of Work}
Describe the rationale behind NIPoPoWs, what they provide
\subsubsection{Prefix Proofs}
Describe prefix proofs
\subsubsection{Suffix Proofs}
Describe suffix proofs
\subsubsection{Infix Proofs}
Describe infix proofs
\subsection{Forks}
Soft, hard and velvet fork

\section{Implementation}
In this section, the implementation steps are described. We also outline the difficulties we faced.

\subsection{Setting up test environment}
A testing environment is a setup of software to execute test cases. Test bed or test environment is configured as per the need of the application under test. Setting up a right test environment ensures software testing success.

In the case of solidity applications, smart contracts are deployed on the EVM. The functionality of the deployed application is tested by making calls to the contract's functions and asserting the correctness of the results. In order to ensure that the contract always operates appropriately, all test-cases must be covered. A common practice for developers is to create a local, in-memory blockchain to deploy and test applications.

There is variety of EVMs one can use. We experimented with are Ganache,Geth and Py-EVM.

\subsubsection{Ganache}
\subsubsection{Geth}
\subsubsection{Py-EVM}

\subsection{Targeting vulnerabilities and costly functionalities}

0. Knowledge that extensive gas usage is due to large storage allocation
1. Make old contract compatible with the last version of solidity compiler
2. Create test for all functionalities
3. Identify and fix vulnerabilities
4. Profile contract gas usage
5. Identify expensive operations

\subsection{Restricting gas usage}

Reconsider DAG and ancestors methodology and redesign submission and contest schema:

A: the entity that submits P1
B: the entity that contests with P2

A doesn't need to save in the proof in storage. B can provide the existing proof during contesting.

Use subset: P1{:lca} > P2{:lca}

Realize that subset is not needed. The contesting proof cannot benefit from pre-lca malformed proof. If Pa is valid then we just need to check Pb[lca:]

This is not vulnerable to DOS attacks

Observer the network and contest with the appropriate proof if submitted is not correct.

\section{Results}
\section{Conclusion}
\section{Future Work}
\end{document}
